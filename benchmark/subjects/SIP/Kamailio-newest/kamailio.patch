diff --git a/src/main.c b/src/main.c
index e0f3720e52..4935b5a4ad 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1472,9 +1472,9 @@ int main_loop(void)
 		/* Register the children that will keep updating their
 		 * local configuration */
 		cfg_register_child(1   /* main = udp listener */
-						   + 1 /* timer */
+						//    + 1 /* timer */
 #ifdef USE_SLOW_TIMER
-						   + 1 /* slow timer */
+						//    + 1 /* slow timer */
 #endif
 		);
 		if(do_suid() == -1)
@@ -1510,14 +1510,12 @@ int main_loop(void)
 
 #ifdef USE_SLOW_TIMER
 		/* we need another process to act as the "slow" timer*/
-		pid = fork_process(PROC_TIMER, "slow timer", 0);
+		/* pid = fork_process(PROC_TIMER, "slow timer", 0);
 		if(pid < 0) {
 			LM_CRIT("Cannot fork\n");
 			goto error;
 		}
 		if(pid == 0) {
-			/* child */
-			/* timer!*/
 			if(real_time & 2)
 				set_rt_prio(rt_timer2_prio, rt_timer2_policy);
 
@@ -1527,29 +1525,29 @@ int main_loop(void)
 		} else {
 			slow_timer_pid = pid;
 		}
+		*/
 #endif
 		/* we need another process to act as the "main" timer*/
+		/*
 		pid = fork_process(PROC_TIMER, "timer", 0);
 		if(pid < 0) {
 			LM_CRIT("Cannot fork\n");
 			goto error;
 		}
 		if(pid == 0) {
-			/* child */
-			/* timer!*/
 			if(real_time & 1)
 				set_rt_prio(rt_timer1_prio, rt_timer1_policy);
 			if(arm_timer() < 0)
 				goto error;
 			timer_main();
 		} else {
-			/* do nothing for main timer */
 		}
 
 		if(sr_wtimer_start() < 0) {
 			LM_CRIT("Cannot start wtimer\n");
 			goto error;
 		}
+		*/
 		/* main process, receive loop */
 		process_no = 0; /*main process number*/
 		pt[process_no].pid = getpid();
@@ -1586,11 +1584,11 @@ int main_loop(void)
 		/* Register the children that will keep updating their
 		 * local configuration. (udp/tcp/sctp listeneres
 		 * will be added later.) */
-		cfg_register_child(1 /* timer */
+		// cfg_register_child(1 /* timer */
 #ifdef USE_SLOW_TIMER
-						   + 1 /* slow timer */
+						//    + 1 /* slow timer */
 #endif
-		);
+		// );
 
 		for(si = udp_listen; si; si = si->next) {
 			/* create the listening socket (for each address)*/
@@ -1994,12 +1992,12 @@ int main_loop(void)
 
 #ifdef USE_SLOW_TIMER
 		/* fork again for the "slow" timer process*/
+		/*
 		pid = fork_process(PROC_TIMER, "slow timer", 1);
 		if(pid < 0) {
 			LM_CRIT("cannot fork \"slow\" timer process\n");
 			goto error;
 		} else if(pid == 0) {
-			/* child */
 			if(real_time & 2)
 				set_rt_prio(rt_timer2_prio, rt_timer2_policy);
 			if(arm_slow_timer() < 0)
@@ -2008,15 +2006,16 @@ int main_loop(void)
 		} else {
 			slow_timer_pid = pid;
 		}
+		*/
 #endif /* USE_SLOW_TIMER */
 
 		/* fork again for the "main" timer process*/
+		/*
 		pid = fork_process(PROC_TIMER, "timer", 1);
 		if(pid < 0) {
 			LM_CRIT("cannot fork timer process\n");
 			goto error;
 		} else if(pid == 0) {
-			/* child */
 			if(real_time & 1)
 				set_rt_prio(rt_timer1_prio, rt_timer1_policy);
 			if(arm_timer() < 0)
@@ -2027,7 +2026,7 @@ int main_loop(void)
 			LM_CRIT("Cannot start wtimer\n");
 			goto error;
 		}
-
+		*/
 		/* init childs with rank==MAIN before starting tcp main (in case they want
 	 * to fork  a tcp capable process, the corresponding tcp. comm. fds in
 	 * pt[] must be set before calling tcp_main_loop()) */
